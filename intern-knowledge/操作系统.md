# 操作系统基础知识

### 系统调用

操作系统为了更好的管理有些资源，例如I/O等，不允许用户直接操作，而必须由操作系统来控制，而操作的入口就是系统调用（System call）

而系统调用是用户访问内核空间的唯一手段，除了异常和陷入之外，他们是内核空间的唯一合法入口

操作系统通过中断完成从用户态切换到内核态，中断号用于标识不同的中断，不同的中断有不同的处理程序，在内核中维护了一个中断向量表

#### 为什么需要系统调用

为了和用户空间上运行的进程进行交互，内核提供了一组接口，通过接口就可以访问硬件设备和操作系统的资源，主要是为了保证操作系统的稳定，防止用户程序随意调用系统命令

主要有以下三个优点：

- 它为用户空间提供了一种统一的硬件的抽象接口。比如当需要读些文件的时候，应用程序就可以不去管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型。
- 系统调用保证了系统的稳定和安全。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决避免应用程序不正确地使用硬件设备，窃取其他进程的资源，或做出其他什么危害系统的事情
- 每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口，如果用户随意访问硬件等资源就无法实现多任务和虚拟内存了

####基本原理

1. 用户程序为系统调用设置参数。其中一个参数是系统调用编号
2. 他们之间通过寄存器进行信息的传递，包括系统调用号以及参数
3. 参数设置完成后，程序执行“系统调用”指令。x86系统上的软中断由int产生。这个指令会导致一个异常：产生一个事件，这个事件会致使处理器切换到内核态并跳转到一个新的地址，并开始执行那里的异常处理程序

## 进程间通信IPC

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走

### 传统的Unix通信机制

#### 1.管道/匿名管道（pipe）

- 管道是半双工的，只能朝一个方向流动，当需要双工通信的时候，建立两个管道
- 一个进程向管道到中写的内容被另一端的进程读出，

**管道的实质**

管道的实质是一个内核缓冲区，以先进先出的方式从缓冲区存取数据

#### 2.有名管道（FIFO）

匿名管道由于没有名字，只能用于父子进程通信

有名管道以文件形式存放在文件系统中，只要可以访问路径就可以通过有名管道进行彼此通信

有名管道的名字放在文件系统中，内容放在内存中

#### 3.信号（Signal）

- 信号可以在任何时候发给另一个进程，而不需要知道进程的状态

- 如果当前进程处于未执行状态，就通过内核保存起来，直到进程恢复执行
- 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程

##### 信号的生命周期

1. 信号由某个进程产生，并且设置了进程传递的对象（对应进程的PID），然后传递给操作系统
2. 操作系统根据进程的设置，选择性的发送给接受者，如果选择阻塞，操作系统暂时保留信号，如果进程退出就丢弃信号，否则就向这个进程传递
3. 目标进程收到之后按照信号设置的预处理的方式处理，中断，保留上下文，转到中断处理的服务进程，执行完成之后回到中断的位置

![](./lifecycle-signal.png)

#### 4.消息队列(Message Queue)

- 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示
- 消息队列存放在内核中，只有在内核中存放
- 消息队列在往里写的时候不需要另一个进程等待消息队列的到达

> **总结**
>
> 1. 消息队列是链表，有特定的格式，放在链表中
> 2. 允许一个或多个进程读写消息
> 3. 克服了信号承载信息少，缓冲区受限等缺点
> 4. 两种主要的消息队列：POSIX和SystemV

####5.共享内存（share memory）

- 使得多个进程可以直接读写同一块内存空间
- 为了多进程信息的转换，内核中专门留出了 一块内存区，访问进程把它映射到自己的私有地址空间空间中，进程读写不需要拷贝
- 多个进程共享同一段内存，需要依靠同步机制（信号量）来达到进程间的同步及互斥

#### 6.信号量

（1）**创建一个信号量**：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
（2）**等待一个信号量**：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。
（3）**挂出一个信号量**：该操作将信号量的值加1，也称为V操作。

#### 7.套接字(socket)

套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。

**套接字特性**
套接字的特性由3个属性确定，它们分别是：域、端口号、协议类型。

一种是**AF_INET，它指的是Internet网络**，IP地址和端口来指定一台联网机器上的某个特定服务

另一种是**AF_UNIX，表示UNIX文件系统**，就是文件输入/输出，而它的地址就是文件名。

## IO复用

通过一种机制，一个进程可以监视多个描述符，一旦描述符就绪（读就绪或者写就绪），能够通知程序进行相应的读写操作，这些读写操作都是阻塞的

对比多线程技术，I/O复用技术最大的优势最大的优势就是系统的开销小，系统不必为其创建进程/线程，系统的开销小，不必维护这些线程

#### select简介

1. select使用数组存储文件描述符，因此单个进程能够监控的文件描述符有最大数量有限制，一般为2048

2. 对socket的扫描是线性的，采用轮训的办法，效率低
3. 如果能够给套接字注册一个回调函数，活跃的时候通知，完成相应的操作，就能够避免轮训
4. 维护了一个数据结构存放fd，使得内核空间和用户空间传递该结构的时候开销比较大

####poll简介

poll与select类似，只不过使用链表来存储文件描述符，没有最大链接数量限制

同样也是通过遍历的方式，效率低

#### epoll简介

1. epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次
2. 使用事件的方式进行通知，通过注册fd，一旦就绪就使用回调的放置激活fd

分为水平触发和边缘触发两种：

**水平触发通知：**

如果文件描述符上可以非阻塞地执行I/O系统调用，此时认为它已经就绪，触发通知。 

 这一次不处理，下一次还是会触发通知

**边沿触发通知：**

如果文件描述符自上次状态检查以来有了新的I/O活动(比如新的输入)，此时需要触发通知

此时不立即处理该事件，当下次再调用epoll监听时，虽然该文件描述符的状态是可读的，但是此时epoll并不会再给应用程序发送通知。因为在边沿触发工作模式下，只有下一个新的I/O事件到来时，才会再次发送通知​     

**优点**

1. 没有最大的并发链接限制
2. 效率提升，不是采用轮询的方式，不会因为fd的数量增加而导致效率下降

#### 总结

1. 表面上看epoll的性能最好，`但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好`，毕竟epoll的通知机制需要很多函数回调。
2. `select低效是因为每次它都需要轮询`。但低效也是相对的，视情况而定，也可通过良好的设计改善。

## 操作系统—虚拟内存

**虚拟内存技术允许执行进程不必完全在内存中，这种方案的一个显著的优点就是程序可以比物理内存大，而且，虚拟内存将内存抽象成一个巨大的，同统一的存储数组，进而将用户看到的逻辑内存与物理内存分开，这种技术允许程序员不受内存存储的限制，虚拟内存页允许进程很容易的共享文件和地址空间**

#### 虚拟内存

虚拟内存将用户的逻辑和物理的内存分开，使得用户无需担心物理上的放置

![](./virtual-memory.png)

#### 进程的虚拟空间

进程的虚拟地址空间就是进程如何在内存中存放的逻辑(或虚拟)试图，通常，该视图为进程从某一逻辑地址(如地址0)开始，连续存放，如图:

![](./virtualaddress.png)

堆可向上生长，类似的，还允许随着子程序的不断调用，栈可以向下生长，堆与栈之间的巨大空白空间(或洞)为虚拟地址的一部分,只有堆和栈生长的时候才需要分配实际的物理页

优点：

- 共享对象映射到虚拟地址空间，系统库可为多个进程只读的方式共享，虽然每个进程都认为共享库是其虚拟地址空间的一部分，而共享库所用的物理内存的实际页是为所有的进程所共享

- 两个或多个进程之间可以通过共享内存来通信，虚拟内存允许一个进程创建内存区域，以便与其他进程进行共享，共享该内存区域的进程认为它是其虚拟地址空间的一部分。而事实上这部分是共享的

#### 如何调度

- 按需要时才调入相应的页，这种技术称为**按需调页(demand paging)**,常为虚拟内存系统所采用。对于按需调页虚拟内存，只有程序执行需要时才载入页，那些从未访问的页不会调入到物理内存。

#### 总结

因此，一些地址在虚拟空间上是连续的，而在物理空间上不一定是连续的，可能跨页了