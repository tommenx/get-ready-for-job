# go语言特性学习

本文主要总结了go语言的一些特性

## go语言包管理机制

>  godep 

`curl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh`

首先安装好dep，编写程序，正常地引入你需要的包

```go
import (
    "net/http"

    "go.uber.org/zap"

    "github.com/beego/mux"
)

func main() {
    logger, _ := zap.NewProduction()
    defer logger.Sync()
    sugar := logger.Sugar()

    mx := mux.New()
    mx.Handler("GET", "/", http.FileServer(http.Dir(".")))
    sugar.Fatal(http.ListenAndServe("127.0.0.1:8080", mx))
}
```

> dep init

使用dep进行包管理，首先在这个项目的根目录下执行dep init，进行初始化，会检查当前包引入的的情况，下载包到`./vendor`，并且会生成另外两个引用信息的文件，记录了包的版本等信息

```shell
dep init -v
```

可以将Gopkg.toml和Gopkg.lock作为源码的一部分提交，可以非常容易的进行`rebuild`

> dep ensure

有了`Gopkg.toml`和`Gokg.lock`之后，由于本地的vendor目录并不存在，可以使用这个命令下载vendor下的东西

> dep ensure update

手动更改`Gopkg.toml`中的库文件的版本信息之后，使用dep ensure -update更新依赖

## go语言的并发机制

#### 线程调度模型

首先有三种线程模型，他们之间的区别是线程与**内核调度实体**Kernel Scheduling Entity(KSE)之间的关系上

##### 1. 内核级线程模型

用户线程与KSE是1：1的关系，大部分语言的线程库是使用这种模型，例如Java的thread和Linux的pthread都是对操作系统的线程（内核级线程）的一层封装，创建出来的每一个线程都和不同的KSE静态关联，调度完全由OS的调度器完成。进程的创建、销毁、以及线程的上下文切换的操作都是在OS内部操作，操作的代价非常大

##### 2. 用户线程模型

用户线程和KSE是M：1的关系，这种线程的创建都是、销毁、线程之间的协调都是由用户自己实现的线程库来负责，对操作系统的内核透明，进程所创建的线程与KSE在运行的时候进行动态的关联，其他语言的协程也是使用这种方式，线程的创建，管理，切换的开销都会想对较小，但是又一个致命的缺点，用户线程调用阻塞式的系统调用一旦被踢出CPU就，剩下所有的线程都会被挂起

##### 3. 混合线程模型

用户线程和KSE是M：M关系，为一个线程创建多个KSE，线程在运行的时候可以和多个KSE动态关联，当某个KSE由于工作线程被阻塞挂起之后，剩余的用户线程可以和其他的KSE关联。有时也称为两层线程模型，用户调度器实现用户线程到KSE的调度，内核调度实现KSE到CPU上的调度

三种模型的示意图如下：

![线程调度模型](https://raw.githubusercontent.com/k2huang/blogpost/master/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6/imgs/1.png)

#### Go语言的并发调度G-P-M

![并发的架构](https://raw.githubusercontent.com/k2huang/blogpost/master/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6/imgs/2.png)

**G**：Goroutine，是go语言中的用户态线程，属于用户线程，对操作系统透明

**M**：Machine，和linux pthread库创建出来的线程本质是一样的，都是利用系统调用创建出来的OS线程实体，M的作用就是执行G中包装的并发任务，运行时系统的调度器的职责就是将G公平合理得安排到多个M上执行

**P**：Processor，逻辑处理器，用于管理G对象，并且为G在M上的运行提供了本地化的资源

而且由于P解耦了G和M对象，这样即使M由于被其上正在运行的G阻塞住，其余与该M关联的G也可以随着P一起迁移到别的活跃的M上继续运行，从而让G总能及时找到M并运行自己，从而提高系统的并发能力。

因此，**调度器负责将并发任务分配到不同的内核线程上运行，然后内核调度器接管内核线程在CPU上的执行与调度。**

### go语言的垃圾回收

go语言使用了**三色法进行垃圾回收**，同时需要**减少STW**的时间，同时需要**辅助回收**机制防止内存快速用完

#### 标记清理

1. 垃圾回收第一次启动的时候把所有的对象都标记成白色，如果这个对象引用了其他的对象，被引用的对象变成灰色放入队列中，第一次扫描结束之后，存在白色对象（不需要管）灰色对象（重新扫描）
2. 灰色对象拿出来之后本身变成黑色，其他引用了这个对象的对象变成灰色加入到队列中，最终就变成了两种颜色对象，黑色和白色，白色的对象需要清理掉
3. 从root对象开始扫描，线程栈，全局变量都是根对象

#### 写屏障

如果一个对象被标记成白色，用户逻辑突然引用了它，过程如下：

1. 首先进行一次很短的STW，简单处理状态
2. 新建的对象当做黑色，这一次不进行处理，接下来扫描已经处理过的对象
3. 对于扫描过后的对象，使用操作系统的写屏障功能来监控用户逻辑段内存，任何改变都会造成写屏障发生信号，GC就会捕捉到，重新扫描这个对象，判断它的被应用状态是否发生了改变

#### STW（stop the world）

在扫描之前会进行STW操作，runtime把所有的线程都冻结掉，会导致用户的逻辑暂停

如何减短这个过程：

1. 扫描过后只有黑色对象和白色对象，黑色对象是接下来程序恢复之后需要使用的，只回收白色对象不会与用户逻辑产生关联
2. 回收操作和用户的逻辑可以是并发的，因此回收阶段是不算在STW时间的

#### 辅助回收

如果对象分配的速度快于扫描的速度，那么会导致用户内存使用膨胀，垃圾回收永远完成不了

go语言发现回收的速度跟不上分配的速度后会暂停用户逻辑，同时把用户的线程抢占用于执行垃圾回收的进程，加快垃圾回收的速度

#### 控制器

控制器全程参与并发回收任务，记录相关状态的数据，动态调整运行策略，平衡CPU资源的占用

## 闭包

闭包是指内层函数引用了外层函数中的变量或称为引用了自由变量的函数，其返回值也是一个函数

### 作用

闭包的作用及好处：闭包给访问外部函数定义的内部变量创造了条件。也将关于函数的一切封闭到了函数内部，减少了全局变量

当每次调用函数A时都要改变全局变量B，且B只与A有关。以往没有闭包时只能将B定义为全局变量，现在可以将B定义为A的内部变量，同时在A内部定义闭包C，并将C当值返回

相当于就是带状态的函数，但是上面的理解可能不太正确

##### 举例

```go
func adder() func(int) int {
    sum := 0
    return func(x int) int {
        sum += x
        return sum
    }
}
```

每一次操作都会更新一下环境中的sum的值，相当于作为一个全局的变量

#### 坑

```go
func main() {                
    s := []string{"a", "b", "c"}                             
    for _, v := range s { 
        go func() {
            fmt.Println(v)
        }()                 
    }                        
    select {}    // 阻塞模式                                                         
}   
```

结果为`ccc`，因为在没有将变量 `v` 的拷贝值传进匿名函数之前，只能获取最后一次循环的值,这是新手最容易遇到的坑。

```go
package main

import (
    "fmt"
)

func test() []func() {
    var s []func()

    for i := 0; i < 3; i++ {
        s = append(s, func() {  //将多个匿名函数添加到列表
            fmt.Println(&i, i)
        })
    }

    return s    //返回匿名函数列表
}
func main() {
    for _, f := range test() {  //执行所有匿名函数
        f()   
    }
}
```

每次都只是append到函数的列表中，执行的时候都是最后一个变量i的值，修改可以通过传入一个变量