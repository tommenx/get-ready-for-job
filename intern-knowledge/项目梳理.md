## 可伸缩的键值存储系统

### 简略版

实现一个可伸缩的分布式键值存储系统，我的工作是让整个系统跑在k8s上，并根据系统的负载进行横向和纵向伸缩的结合，让系统能够更加经济得承载系统的动态负载

### 详细版

1. 基于(用户自定义资源)crd实现了一个控制器，能够根用户期待的系统的状态，创建，部署集群的各个部分
2. 基于逻辑卷和CSI拓展了k8s本地存储插件，实现数据持久卷的动态创建，磁盘的隔离，限制了空间大小，支持挂载不同的文件系统，由于k8s对于本地存储的支持并不好，使用的是文件夹挂载的方式，无法限制写空间的大小，并且需要提前创建PV等缺点，因此通过我们的拓展插件，使得系统能够进行纵向得伸缩
3. 通过获取kv系统内部的监控，以及宿主机的状态，进行横向和纵向的扩容，目前只实现了横向的扩容，由于扩容的是存储节点，策略还在不断的测试中

##基于raft协议的分布式键值存储系统

### 简略版

学习了mit6.824跟着实验实现了通过raft协议维持副本一致性的基于元数据服务器的分布式键值存储系统，将数据的分片用多个raft组进行管理

### 详细版

1. 首先，集群中有两种角色的节点，包括元数据节点和数据节点，数据节点以raft组的形式向外提供服务

2. 为了读取某个key的值，需要有两层映射，通过静态的哈希找到数据所在的分片序号，又通过元数据服务器获取的元数据信息，得到分片和所在数据节点，也就是raft组的映射

**实现的难点**

节点的动态加入和删除涉及到了数据分片的迁移，如果在这个过程中遇到网络或者单点故障就会有以下两个问题：

1. 不同raft组可能会因为元数据的信息数据版本不一致，导致无法迁移
2. 在迁移过程中，如果更换了leader，会导致迁移过程终止

**解决的办法**

> 元数据版本不一致

数据节点也会定期访问元数据服务器，更新自己的元数据信息，当元数据版本不一致的时候就会等待，直到元数据信息一致了之后，向日志中添加Transfer，传送完毕之后写入transferFinish日志

接收方：

- 过时的版本直接丢弃
- 相同版本就添加进自己的系统状态中
- 先用一个buffer缓存，当未来版本到达的时候再merge到系统的状态中

从而解决了因为元数据不同导致数据迁移无法成功

> raft组中leader更换导致迁移终止

因为有了日志的记录，直到日志apply到transferFinish才会停止传输，因此，可以通过查看日志的状态，来判断数据是否传送完





